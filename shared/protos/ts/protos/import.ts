/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.32.1
 * source: protos/import.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class ImportRequest extends pb_1.Message {
    #one_of_decls: number[][] = [[2, 3]];
    constructor(data?: any[] | ({
        Options?: Options;
    } & (({
        Html?: ImportHtmlDetails;
        Markdown?: never;
    } | {
        Html?: never;
        Markdown?: ImportMarkdownDetails;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Options" in data && data.Options != undefined) {
                this.Options = data.Options;
            }
            if ("Html" in data && data.Html != undefined) {
                this.Html = data.Html;
            }
            if ("Markdown" in data && data.Markdown != undefined) {
                this.Markdown = data.Markdown;
            }
        }
    }
    get Options() {
        return pb_1.Message.getWrapperField(this, Options, 1) as Options;
    }
    set Options(value: Options) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_Options() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get Html() {
        return pb_1.Message.getWrapperField(this, ImportHtmlDetails, 2) as ImportHtmlDetails;
    }
    set Html(value: ImportHtmlDetails) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_Html() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get Markdown() {
        return pb_1.Message.getWrapperField(this, ImportMarkdownDetails, 3) as ImportMarkdownDetails;
    }
    set Markdown(value: ImportMarkdownDetails) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_Markdown() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get Details() {
        const cases: {
            [index: number]: "none" | "Html" | "Markdown";
        } = {
            0: "none",
            2: "Html",
            3: "Markdown"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2, 3])];
    }
    static fromObject(data: {
        Options?: ReturnType<typeof Options.prototype.toObject>;
        Html?: ReturnType<typeof ImportHtmlDetails.prototype.toObject>;
        Markdown?: ReturnType<typeof ImportMarkdownDetails.prototype.toObject>;
    }): ImportRequest {
        const message = new ImportRequest({});
        if (data.Options != null) {
            message.Options = Options.fromObject(data.Options);
        }
        if (data.Html != null) {
            message.Html = ImportHtmlDetails.fromObject(data.Html);
        }
        if (data.Markdown != null) {
            message.Markdown = ImportMarkdownDetails.fromObject(data.Markdown);
        }
        return message;
    }
    toObject() {
        const data: {
            Options?: ReturnType<typeof Options.prototype.toObject>;
            Html?: ReturnType<typeof ImportHtmlDetails.prototype.toObject>;
            Markdown?: ReturnType<typeof ImportMarkdownDetails.prototype.toObject>;
        } = {};
        if (this.Options != null) {
            data.Options = this.Options.toObject();
        }
        if (this.Html != null) {
            data.Html = this.Html.toObject();
        }
        if (this.Markdown != null) {
            data.Markdown = this.Markdown.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_Options)
            writer.writeMessage(1, this.Options, () => this.Options.serialize(writer));
        if (this.has_Html)
            writer.writeMessage(2, this.Html, () => this.Html.serialize(writer));
        if (this.has_Markdown)
            writer.writeMessage(3, this.Markdown, () => this.Markdown.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImportRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.Options, () => message.Options = Options.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.Html, () => message.Html = ImportHtmlDetails.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.Markdown, () => message.Markdown = ImportMarkdownDetails.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ImportRequest {
        return ImportRequest.deserialize(bytes);
    }
}
export class Options extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        Id?: string;
        ImportImages?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("Id" in data && data.Id != undefined) {
                this.Id = data.Id;
            }
            if ("ImportImages" in data && data.ImportImages != undefined) {
                this.ImportImages = data.ImportImages;
            }
        }
    }
    get Id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set Id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get ImportImages() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set ImportImages(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        Id?: string;
        ImportImages?: boolean;
    }): Options {
        const message = new Options({});
        if (data.Id != null) {
            message.Id = data.Id;
        }
        if (data.ImportImages != null) {
            message.ImportImages = data.ImportImages;
        }
        return message;
    }
    toObject() {
        const data: {
            Id?: string;
            ImportImages?: boolean;
        } = {};
        if (this.Id != null) {
            data.Id = this.Id;
        }
        if (this.ImportImages != null) {
            data.ImportImages = this.ImportImages;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.Id.length)
            writer.writeString(1, this.Id);
        if (this.ImportImages != false)
            writer.writeBool(2, this.ImportImages);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Options {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Options();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.Id = reader.readString();
                    break;
                case 2:
                    message.ImportImages = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Options {
        return Options.deserialize(bytes);
    }
}
export class ImportHtmlDetails extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        CssSelector?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("CssSelector" in data && data.CssSelector != undefined) {
                this.CssSelector = data.CssSelector;
            }
        }
    }
    get CssSelector() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set CssSelector(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_CssSelector() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _CssSelector() {
        const cases: {
            [index: number]: "none" | "CssSelector";
        } = {
            0: "none",
            1: "CssSelector"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        CssSelector?: string;
    }): ImportHtmlDetails {
        const message = new ImportHtmlDetails({});
        if (data.CssSelector != null) {
            message.CssSelector = data.CssSelector;
        }
        return message;
    }
    toObject() {
        const data: {
            CssSelector?: string;
        } = {};
        if (this.CssSelector != null) {
            data.CssSelector = this.CssSelector;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_CssSelector)
            writer.writeString(1, this.CssSelector);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportHtmlDetails {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImportHtmlDetails();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.CssSelector = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ImportHtmlDetails {
        return ImportHtmlDetails.deserialize(bytes);
    }
}
export class ImportMarkdownDetails extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data: {}): ImportMarkdownDetails {
        const message = new ImportMarkdownDetails({});
        return message;
    }
    toObject() {
        const data: {} = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImportMarkdownDetails {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ImportMarkdownDetails();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ImportMarkdownDetails {
        return ImportMarkdownDetails.deserialize(bytes);
    }
}
